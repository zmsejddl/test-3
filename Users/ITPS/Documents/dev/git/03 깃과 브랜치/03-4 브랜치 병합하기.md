# 03-4 브랜치 병합하기
- 브랜치마다 각자 커밋할 수 있더라도 어느 시점에서는 브랜치 작업을 마무리하고 기존 브랜치와 합쳐야 한다. 이것을 브랜치 병합(merge)이라고 한다

**서로 다른 파일 병합하기**
1. 홈 디렉터리에 manual-2라는 디렉터리를 만들고 깃 저장소를 만들겠다. 2가지 과정을 한꺼번에 처리해 보겠다
```bash
$ git init manual-2
```
2. work.txt 파일을 만들고 '1'을 입력한 후 저장. 그리고 'work 1'이라는 메시지와 함께 커밋한다
3. 'o2'라는 브랜치를 만들어 보겠다
4. main 브랜치에 main.txt라는 파일을 하나 더 만들겠다. 'main 2'라고 입력한 후 저장한다. 그리고 'main work 2'라는 메시지와 함께 커밋
5. o2 브랜치에서 o2.txt라는 파일을 만들고, '2'라는 내용을 입력한 후 저장한다. 이어서 o2.txt 파일은 'o2 work 2'라는 메시지와 함께 커밋
6. o2 브랜치에서 작업이 모두 끝났다고 가정해 본다. 그렇다면 o2 브랜치의 내용을 main 브랜치로 병합해야 한다. 브랜치를 병합하려면 먼저 main 브랜치로 전환해야 한다
7. 브랜치를 병합할 때는 git merge 명령 뒤에 가져올 브랜치 이름을 적는다
```bash
$ git merge o2
```
8. o2 브랜치에 있던 o2.txt 파일이 main 브랜치에 합쳐졌을 것이다
9. git log 명령으로 브랜치와 커밋이 어떻게 병합되었는지 확인할 수도 있다

**빨리 감기 병합이란?**
- main 브랜치에서 브랜치를 분기한 후에 main 브랜치에 아무 변화가 없다면(새로운 커밋을 만들지 않았다면) 분기한 브랜치에서 만든 최신 커밋을 main 브랜치가 가리키게만 하면 된다. 이 경우에는 화면에 커밋 해시가 업데이트되었다는 내용과 함께 fast-forward라는 메시지가 나타난다. 이런 병합을 빨리 감기 병합(fast-forward merge)이라고 한다

**서로 다른 브랜치에서 한 문서의 다른 부분을 수정했을 때 병합하기**
- 같은 문서에서 사로 다른 부분을 수정했을 때 병합하는 과정을 살펴보겠다
1. 홈 디렉터리로 이동한 후 'manual-3'이라는 깃 저장소를 만들고, manual-3 디렉터리로 이동
2. work.txt 파일을 만들고 다음과 같이 입력한다
```bash
#title
content

#title
content
```
3. 방금 만든 work.txt를 스테이지에 올리고 커밋한다. 커밋 메세지는 'work 1'이라고 하겠다
4. 'o2'라는 새로운 브랜치를 만든다
5. 우선 main 브랜치에서 문서를 수정해 보겠다
6. 첫 번째 공백 줄에 'main content 2'라고 입력한 후 저장한다
7. 커밋한다. 커밋 메세지는 'main work 2'라고 하겠다
8. o2 브랜치의 work.txt 파일도 수정한다
9. 두번 째 공백 줄에 'o2 content 2'라고 입력하고 저장한다
10. 커밋한다. 커밋 메세지는 'o2 work 2'라고 하겠다
11. 브랜치 양쪽에서 한 문서를 수정했다. 이 상태에서 병합해 보겠다
12. main 브랜치로 끌어 온다
13. conflict 이 메세지는 work.txt를 자동 병합하는 동안 충돌이 발생했다는 뜻이다
14. 사용자가 충돌 부분을 직접 해결한 후 커밋해야 한다
15. 수정한 work.txt를 스테이지에 올리고 커밋하면 된다. 커밋 메세지는 merge o2 branch로 하겠다

**병합 및 충돌 해결 프로그램**
- 깃의 브랜치 병합을 자동으로 처리해 주고 충돌을 해결해 주는 프로그램이 많다. 협업시에는 병합 자동화 프로그램도 사용을 고려해 보자

**병합이 끝난 브랜치 삭제하기**
- 브랜치를 병합한 후 더 이상 사용하지 않는 브랜치는 깃에서 삭제할 수 있다. 단, 이렇게 브랜치를 삭제하더라도 완전히 지워지는 것은 아니며 같은 이름의 브랜치를 만들면 예전 내용을 다시 볼 수 있다
1. 현재 저장소에 어떤 브랜치가 있는지 확인한다
2. main 브랜치로 전환
3. o2 브랜치를 삭제한다
```bash
$ git branch -d o2
```
4. 브랜치 삭제가 되었지만 삭제한 브랜치는 같은 이름으로 다시 브랜치를 만들면 예전에 작업했던 내용이 그대로 나타난다. 즉, 브랜치를 삭제한다는 것은 깃의 흐름 속에서 감추는 것이라고 생각하면 된다

**cherry-pick으로 병합하기**
- 깃에 'cherry-pick'이라는 또 하나의 병합 방법이 있다
- cherry-pick은 브랜치와 브랜치를 합치긴 하는데 브랜치 전체를 합치는게 아니라, 브랜치 중 특정 버전의 변경 내용만 합치려고 할 때 사용하는 기능이다
1. 홈 디렉터리에 cherry-pick 디렉터리를 깃 저장소로 만들고, cherry-pick 디렉터리로 이동한다
2. 우선 새로운 브랜치를 만들기 전에 버전을 만들어 보겠다. 터미널에서 세미 콜론(;) 구분해서 여거 개의 명령을 한꺼번에 처리할 수 있다. 명령어 중 touch는 vim 파일을 만든다
```bash
$ touch init.txt; git add init.txt; git commit -m "init"
```
3. 새로운 브랜치 topic을 만든다. git log 옵션 중에 --all 옵션은 최신 커밋 뿐만 아니라 모든 커밋을 다 보여주기 위한 옵션이다
```bash
$ git branch topic
$ git log --oneline --all --graph
```
4. 이제 main 브랜치에 m1과 m2라는 2개의 버전을 더 만들어 보겠다. 그리고 git log로 확인해 본다
```bash
$ touch m1; git add m1; git commit -m "m1"
$ touch m2; git add m2; git commit -m "m2"
$ git log --oneline --all --graph
```
5. topic 브랜치로 전환한 후, t1, t2, t3 버전을 만든다
```bash
$ git switch topic
$ touch t1; git add t1; git commit -m "t1"
$ touch t2; git add t2; git commit -m "t2"
$ touch t3; git add t3; git commit -m "t3"
$ git log --oneline --all --graph
```
6. topic 브랜치의 t2 버전에서 적용했던 내용을 main 브랜치에도 적용하고 싶을 때 사용하는 것이 바로 cherry-pick이다. topic 브랜치의 여러 버전 중 하나를 골라와서 병합하는 것이다. 우선 main 브랜치로 전환한다
```bash
$ git switch main
```
7. topic 브랜치의 t2 버전만 병합하려면, cherry-pick 명령 다음에 t2에 해당하는 커밋 해시를 알려주면 된다
```bash
$ git cherry-pick 체리픽할 해시
```
8. t2 파일도 잘 복사가 됐고 커밋도 main 브랜치에 t2가 추가되어 있다